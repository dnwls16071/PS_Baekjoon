# IPv6은 길이가 128비트인 차세대 인터넷 프로토콜이다.
#
# IPv6의 주소는 32자리의 16진수를 4자리씩 끊어 나타낸다. 이때, 각 그룹은 콜론 (:)으로 구분해서 나타낸다.
#
# 예를 들면, 다음과 같다.
#
# 2001:0db8:85a3:0000:0000:8a2e:0370:7334
# 32자리의 16진수는 사람이 읽고 쓰기에 불편하고, 대부분의 자리가 0이기 때문에 아래와 같이 축약할 수 있다.
#
# 각 그룹의 앞자리의 0의 전체 또는 일부를 생략 할 수 있다. 위의 IPv6을 축약하면, 다음과 같다
# 2001:db8:85a3:0:00:8a2e:370:7334
# 만약 0으로만 이루어져 있는 그룹이 있을 경우 그 중 한 개 이상 연속된 그룹을 하나 골라 콜론 2개(::)로 바꿀 수 있다.
# 2001:db8:85a3::8a2e:370:7334
# 2번째 규칙은 모호함을 방지하기 위해서 오직 한 번만 사용할 수 있다.
#
# 올바른 축약형 IPv6주소가 주어졌을 때, 이를 원래 IPv6 (32자리의 16진수)로 복원하는 프로그램을 작성하시오.

import sys
input = sys.stdin.readline

ipv6 = input().strip()
# 입력 문자열을 ":"을 기준으로 나눠 리스트에 담는다.
ipv6 = list(ipv6.split(":"))

result = [""] * 8
idx = 0
flag = 0
for i in range(len(ipv6)):
    # 각 칸이 4자라면 복구 전과 후가 동일하므로 그대로 옮긴다.
    if len(ipv6[i]) == 4:
        result[idx] = ipv6[i]
        idx += 1
    # 0보다 크고 4보다 작으면 0의 일부만 생략된 것이므로 해당하는 수만큼 0을 추가한다.
    elif len(ipv6[i]) > 0:
        result[idx] = '0' * (4 - len(ipv6[i])) + str(ipv6[i])
        idx += 1
    # 만약 0으로만 이루어져 있는 그룹이 있을 경우 그 중 한 개 이상 연속된 그룹을 하나 골라 콜론 2개로 바꿀 수 있다.
    # len(ipv6[i]) = 0
    else:
        # 0이 계속 나올 수 있을 때까지 반복문으로 0000을 채움
        if flag == 0:
            for j in range(8 - len(ipv6) + 1):
                result[idx] = "0000"
                idx += 1
            flag = 1
        # 하나의 그룹만 비어있는 경우 → 0000을 채움
        else:
            result[idx] = "0000"
            idx += 1

for i in range(len(result) - 1):
    print(result[i], end = ":")
print(result[-1])